package nl.tue.tm.is.ptnet;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

import org.apache.commons.collections.CollectionUtils;
import org.xml.sax.helpers.DefaultHandler;

public class PTNet {
	
	Map<String,Place> places;
	Map<String,Transition> transitions;
	Set<Arc> arcs;
	Map<Node,Set<Arc>> arcsBySource;
	Map<Node,Set<Arc>> arcsByTarget;	
	Marking initialMarking;
	Map<Node,Map<String,String>> attributes;

	public static int PNML_PROM = 1;
	public static int PNML_PNK = 2;
	
	public PTNet() {
		places = new HashMap<String,Place>();
		transitions = new HashMap<String,Transition>();
		arcs = new HashSet<Arc>();
		arcsBySource = new HashMap<Node,Set<Arc>>();
		arcsByTarget = new HashMap<Node,Set<Arc>>();
		initialMarking = new Marking();
		attributes = new HashMap<Node,Map<String,String>>();
	}
	
	/** 
	 * Loads a Petri net from a .pnml file (generated by Petri net kernel (PNK) 2.2).
	 * 
	 * @param fileLocation fully qualified .pnml filename to load from. 
	 * @return the Petri net.
	 */
	public static PTNet loadPNML(String fileLocation){
		return loadPNML(fileLocation, "");
	}	
	/**
	 * Loads a Petri net from a .pnml file (generated by Petri net kernel (PNK) 2.2)
	 * and suffixes all id's with suffix.
	 *   
	 * @param fileLocation fully qualified .pnml filename to load from.
	 * @param suffix the suffix for the Petri nets id's. 
	 * @return the Petri net.
	 */
	public static PTNet loadPNML(String fileLocation, String suffix){
		PTNet result = new PTNet();
		
        DefaultHandler handler = new PTNetParser(result, suffix);
        SAXParserFactory factory = SAXParserFactory.newInstance();
        
        try {
            SAXParser saxParser = factory.newSAXParser();
            saxParser.parse(new File(fileLocation), handler);

        } catch (Exception e) {
            e.printStackTrace();
        }
		
		return result;
	}
	
	/**
	 * Adds a place to the net. The place's id must be unique (not checked automatically).
	 * 
	 * @param p the place to add.
	 */
	public void addPlace(Place p){
		places.put(p.getId(), p);
	}
	
	public void removePlace(Place p){
		places.remove(p.getId());
	}
	
	/**
	 * Adds a transition to the net. The transition's id must be unique (not checked automatically).
	 * 
	 * @param t the place to add.
	 */
	public void addTransition(Transition t){
		transitions.put(t.getId(), t);
	}

	public void removeTransition(Transition t){
		transitions.remove(t.getId());
	}

	/**
	 * Adds an arc to the net.
	 * 
	 * @param a the arc to add.
	 */
	public void addArc(Arc a){
		arcs.add(a);
		Set<Arc> arcsFromSource = arcsBySource.get(a.getSource());
		if (arcsFromSource == null){
			arcsFromSource = new HashSet<Arc>();
			arcsFromSource.add(a);
			arcsBySource.put(a.getSource(),arcsFromSource);
		}else{
			arcsFromSource.add(a);
		}
		Set<Arc> arcsToTarget = arcsByTarget.get(a.getTarget());
		if (arcsToTarget == null){
			arcsToTarget = new HashSet<Arc>();
			arcsToTarget.add(a);
			arcsByTarget.put(a.getTarget(),arcsToTarget);
		}else{
			arcsToTarget.add(a);
		}		
	}
	
	public void removeArc(Arc a ){
		arcs.remove(a);
		arcsBySource.get(a.getSource()).remove(a.getTarget());
		arcsByTarget.get(a.getTarget()).remove(a.getSource());
	}

	
	/**
	 * Adds an attribute to the given node. The attribute is a pair (keyword, value).
	 * If the attributes keyword already exists, it is overwritten.
	 * 
	 * @param n	Node to set the atribute for.
	 * @param keyword Attributes keyword.
	 * @param value Attributes value.
	 */
	public void setAttribute(Node n, String keyword, String value){
		Map<String,String> kv = attributes.get(n);
		if (kv == null){
			kv = new HashMap<String,String>();
			attributes.put(n, kv);			
		}
		kv.put(keyword, value);
	}
	/**
	 * Gets the attributes of a given node. An attribute is a pair (keyword, value).
	 * If a node has no attributes, an empty map is returned.
	 * 
	 * @param n Node to return the attributes for.
	 * @return A map that maps keywords to values.
	 */
	public Map<String,String> getAttributes(Node n){
		Map<String,String> result = attributes.get(n);
		if (result == null){
			result = new HashMap<String,String>();
		}
		return result;
	}
	/**
	 * Adds the number of initial tokens for place p to the net.
	 * 
	 * @param p the place.
	 * @param initialTokens the number of tokens initially on the place.
	 */
	public void addMarking(Place p, int initialTokens){
		initialMarking.addMark(p, initialTokens);		
	}
	
	/**
	 * Finds a place by it's id.
	 * 
	 * @param id the id of the place to find.
	 * @return the place found or null if no place is found.
	 */
	public Place findPlace(String id){
		return places.get(id);
	}
	/**
	 * Finds a transition by it's id.
	 * 
	 * @param id the id of the transition to find.
	 * @return the transition found or null if no transition is found.
	 */
	public Transition findTransition(String id){
		return transitions.get(id);
	}
	/**
	 * Finds a transition with the given label. 
	 * 
	 * @param label label to find a transition for.
	 * @return the transition with the given label.
	 */
	public Transition findTransitionByLabel(String label){
		Transition result = null;
		for (Transition t: transitions.values()){
			if (t.getName().equals(label)){
				result = t;
			}
		}
		return result;
	}
	/**
	 * Finds a node (either a place or a transition) by it's id.
	 * 
	 * @param id the id of the node to find.
	 * @return the node found or null if no node is found.
	 */
	public Node findNode(String id){
		Place foundPlace = findPlace(id);
			if (foundPlace != null){
				return foundPlace;
			}else{
				return findTransition(id);
			}
	}
	
	/** 
	 * Returns a string that represents the Petri net. The string is formatted like:
	 * (places, transitions, flows, labeling function, initial marking function).
	 * 
	 * @return a string representing the Petri net.
	 */
	public String toString(){
		String result = "(";
		
		result += "{";
		for (Iterator<Place> i = places.values().iterator();i.hasNext();){
			Place p = i.next();
			result += p.toString();
			if (i.hasNext()){
				result += ",";
			}
		}
		result += "}";

		result += ",";
		
		result += "{";
		for (Iterator<Transition> i = transitions.values().iterator();i.hasNext();){
			Transition t = i.next();
			result += t.toString();
			if (i.hasNext()){
				result += ",";
			}
		}
		result += "}";
		
		result += ",";
		
		result += "{";
		for (Iterator<Arc> i = arcs.iterator();i.hasNext();){
			Arc a = i.next();
			result += a.toString();
			if (i.hasNext()){
				result += ",";
			}
		}
		result += "}";

		result += ",";
		
		result += "{";
		for (Iterator<Transition> i = transitions.values().iterator();i.hasNext();){
			Transition t = i.next();
			result += "(" + t.getId() + "," + t.getName() + ")";
			if (i.hasNext()){
				result += ",";
			}
		}
		result += "}";
		
		result += ",";

		result += initialMarking.toString();
		
		result += ")";
		return result;
	}
	
	/**
	 * Returns the set of transitions that is enabled in the Petri net, under a marking.
	 * 
	 * @param m the marking for which we want to check which transitions are enabled.
	 * @return the set of enabled transitions.
	 */
	public Set<Transition> enabledTransitions(Marking m){
		Set<Transition> result = new HashSet<Transition>();
		
		for (Iterator<Transition> i = transitions.values().iterator(); i.hasNext();){
			Transition t = i.next();
			//find all arcs pointing to the transition
			Set<Arc> arcsPointingTo = arcsByTarget.get(t);
			//find all source places
			if (arcsPointingTo != null){
				boolean tokensOnSourcePlaces = true;
				for (Iterator<Arc> j = arcsPointingTo.iterator(); j.hasNext() && tokensOnSourcePlaces;){
					Arc a = j.next();
					tokensOnSourcePlaces = m.getMark((Place) a.getSource()) > 0;
				}
				if (tokensOnSourcePlaces){
					result.add(t);
				}
			}
		}
		return result;
	}

	/**
	 * Returns the initial marking of the Petri net.
	 * 
	 * @return the initial marking of the Petri net.
	 */
	public Marking getInitialMarking() {
		return initialMarking;
	}

	/**
	 * Returns the marking that is the result of firing a transition in a certain marking.
	 * The transition must be enabled in the marking otherwise the result is undefined.
	 * 
	 * @param m the marking for which to perform the firing. 
	 * @param t the transition to fire.
	 * @return the marking in which the Petri net results after firing the given transition in the given marking.
	 */
	public Marking fireTransition(Marking m, Transition t){
		Marking result = new Marking();
		
		Set<Arc> arcsPointingTo = arcsByTarget.get(t);
		Set<Place> sourcePlaces = new HashSet<Place>();
		if (arcsPointingTo != null){
			for (Iterator<Arc> i = arcsPointingTo.iterator(); i.hasNext();){
				sourcePlaces.add((Place) i.next().getSource());
			}	
		}
		Set<Place> targetPlaces = new HashSet<Place>();
		Set<Arc> arcsOriginatingFrom = arcsBySource.get(t);
		if (arcsOriginatingFrom != null){
			for (Iterator<Arc> i = arcsOriginatingFrom.iterator(); i.hasNext();){
				targetPlaces.add((Place) i.next().getTarget());
			}
		}
		
		for (Iterator<Map.Entry<Place,Integer>> i = m.entrySet().iterator(); i.hasNext();){
			Map.Entry<Place,Integer> e = i.next();
			int nrTokens = e.getValue();
			Place place = e.getKey();
			if (sourcePlaces.remove(place)){
				nrTokens--;
			}
			if (targetPlaces.remove(place)){
				nrTokens++;
			}
			result.addMark(place, nrTokens);
		}
		
		return result;
	}
	
	/**
	 * Returns the set of places in the Petri net. 
	 */
	public Set<Place> places(){
		return new HashSet<Place>(places.values());
	}
	/**
	 * Returns the set of transitions in the Petri net.
	 */
	public Set<Transition> transitions(){
		return new HashSet<Transition>(transitions.values());
	}
	/**
	 * Returns the set of arcs in the Petri net. 
	 */
	public Set<Arc> arcs(){
		return new HashSet<Arc>(arcs);
	}
	/**
	 * Returns the set of labels of the Petri net. 
	 */
	public Set<String> labels(){
		Set<String> result = new HashSet<String>();
		
		for (Iterator<Transition> ts = transitions.values().iterator();ts.hasNext();){
			result.add(ts.next().getName());
		}
		
		return result;
	}
	
	/**
	 * Returns all nodes, i.e., places and transitions.
	 */
	public Set<Node> nodes(){
		Set<Node> result = new HashSet<Node>();
		result.addAll(this.places());
		result.addAll(this.transitions());
		return result;
	}
	

	
	/**
	 * Saves the Petri net as a .pnml file that can be imported by PROM or PNK 2.2.
	 *  
	 * @param fileName fully qualified name of the .pnml file to save as.
	 * @param type can be PNML_PROM or PNML_PNK indicating save as PROM or as PNK, respectively. 
	 */
	public void exportToPNML(String fileName, int type) throws IOException{
		if ((type != PNML_PROM) && (type != PNML_PNK)){
			throw new IOException("Invalid filetype: should be either PROM or PNK");
		}
		
		FileWriter os = new FileWriter(fileName);
		
		os.write("<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n");
		os.write("<pnml>\n");
		os.write("  <net id=\"net\" type=\"PTNet\">\n");
		
		for (Iterator<Place> i = places().iterator();i.hasNext();){
			Place p = i.next();
			
			os.write("    <place id=\"" + p.getId() + "\">\n");
			os.write("      <initialMarking>\n");
			os.write("        <value>" + initialMarking.getMark(p) + "</value>\n");
			os.write("      </initialMarking>\n");
			os.write("      <marking>\n");
			os.write("        <value>" + initialMarking.getMark(p) + "</value>\n");
			os.write("      </marking>\n");
			os.write("      <name>\n");
			if (type == PNML_PROM){
				os.write("        <text>" + p.getName().trim() + "</text>\n");
			}
			if (type == PNML_PNK){
				os.write("        <value>" + p.getName().trim() + "</value>\n");				
			}
			os.write("      </name>\n");
			os.write("      <toolspecific tool=\"ntommatcher\">\n");
			for (Map.Entry<String, String> kv: getAttributes(p).entrySet()){
				os.write("        <attribute keyword=\"" + kv.getKey().trim() + "\">");
				os.write(kv.getValue().trim());
				os.write("</attribute>\n");
			}
			os.write("      </toolspecific>\n");
			os.write("    </place>\n");
		}
				    
		for (Iterator<Transition> i = transitions().iterator();i.hasNext();){
			Transition t = i.next();
			
			os.write("    <transition id=\"" + t.getId() + "\">\n");
			os.write("      <name>\n");
			if (type == PNML_PROM){
				//PROM associated weirdness: silent label equals: any label that does not contain a '\n' 
				os.write("        <text>" + ((t.getName().equals(Transition.SILENT_LABEL) || (t.getName().length() == 0))?"":".\\n") + t.getName().trim() + "</text>\n");
			}
			if (type == PNML_PNK){
				os.write("        <value>" + t.getName().trim() + "</value>\n");				
			}
			os.write("      </name>\n");
			os.write("      <toolspecific tool=\"ntommatcher\">\n");
			for (Map.Entry<String, String> kv: getAttributes(t).entrySet()){
				os.write("        <attribute keyword=\"" + kv.getKey().trim() + "\">");
				os.write(kv.getValue().trim());
				os.write("</attribute>\n");
			}
			os.write("      </toolspecific>\n");
			os.write("    </transition>\n");
		}
		
		for (Iterator<Arc> i = arcs().iterator();i.hasNext();){
			Arc a = i.next();
			
			os.write("    <arc id=\"" + a.getId() + "\" source=\"" + a.getSource().getId() + "\" target=\"" + a.getTarget().getId() + "\">\n");
			os.write("      <inscription>\n");
			os.write("        <value>1</value>\n");
			os.write("      </inscription>\n");
			os.write("    </arc>\n");
		}
		
		os.write("  </net>\n");
		os.write("</pnml>\n");
		
		os.flush();
	}
	
	/**
	 * Returns the preset of a node.
	 */
	public Set<Node> getPre(Node n){
		Set<Node> result = new HashSet<Node>();
		Set<Arc> incoming = arcsByTarget.get(n);
		if (incoming != null){
			for (Iterator<Arc> i = incoming.iterator(); i.hasNext();){
				Arc a = i.next();
				result.add(a.getSource());
			}
		}
		return result;
	}
	
	/**
	 * Returns the postset of a node.
	 */
	public Set<Node> getPost(Node n){
		Set<Node> result = new HashSet<Node>();
		Set<Arc> outgoing = arcsBySource.get(n);
		if (outgoing != null){
			for (Iterator<Arc> i = outgoing.iterator(); i.hasNext();){
				Arc a = i.next();
				result.add(a.getTarget());
			}
		}
		return result;
	}	
	
	/**
	 * Returns the all non-silent transitions that directly preceed a transition.
	 * These are transitions from which there is a path to t, such that there is no non-silent transition on that path. 
	 */
	public Set<Transition> inputTransitionsFor(Transition t, Set<Transition> toSkip){
		Set<Transition> visited = new HashSet<Transition>();
		visited.add(t);
		return inputTransitionForHelper(t, visited, toSkip);
	}	
	private Set<Transition> inputTransitionForHelper(Transition t, Set<Transition> visited, Set<Transition> toSkip){
		Set<Transition> result = new HashSet<Transition>();
		
		for (Iterator<Node> i = getPre(t).iterator(); i.hasNext();){
			for (Iterator<Node> j = getPre(i.next()).iterator(); j.hasNext();){
				Transition tPre = (Transition) j.next(); //for each transition that directly preceeds t
				if (visited.contains(tPre)){ //if it is visited do nothing
				}else if (tPre.getName().equals(Transition.SILENT_LABEL) || toSkip.contains(tPre)){ //if it is silent or skipped add its input transitions that are non-silent
					Set<Transition> visitedPrime = new HashSet<Transition>();
					visitedPrime.addAll(visited);
					visitedPrime.add(tPre);
					result.addAll(inputTransitionForHelper(tPre,visitedPrime,toSkip));
				}else{ //if it is non-silent and non-skipped add it to the result set
					result.add(tPre);
				}				
			}
		}		
		return result;
	}
	
	/**
	 * Checks whether the net is a free choice net.
	 * 
	 * @return true, if the net is free-choice
	 */
	public boolean isFreeChoiceNet() {
		boolean isFC = true;
		
		outer:
		for(Transition t1 : this.transitions()) {
			for(Transition t2 : this.transitions()) {
				if (t1.equals(t2))
					continue;
				Collection<Node> preT1 = this.getPre(t1);
				Collection<Node> preT2 = this.getPre(t2);
				if (CollectionUtils.containsAny(preT1, preT2)) {
					preT1.retainAll(preT2);
					boolean tmp = (preT1.size() == preT2.size());
					isFC &= tmp;
					if (!isFC) 
						break outer;
				}
			}
		}
		return isFC;
	}

}
